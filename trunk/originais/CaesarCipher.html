<html>
<head>
<title>IYOCGwP Book 1 - Chapter 10 - Caesar Cipher</title>
<link rel="stylesheet" href="inventbook.css" type="text/css" media="all">
</head>
<body>

<h1>Chapter 10 - Caesar Cipher</h1>

<h2>About Cryptography</h2>

<p>The science of writing secret codes is called <span class='term'>cryptography</span>. Cryptography has been used for thousands of years to send secret messages that only the recipient could understand, even if someone captured the messenger and read the coded message. A secret code system is called a <span class='term'>cipher</span>. There are thousands of different ciphers that have been used, each using different techniques to keep the messages a secret.</p>

<p>In cryptography, we call the message that we want to be secret the <span class='term'>plaintext</span>. The plaintext could look something like this:</p>

<blockquote style="sourceblurb">Hello there! The keys to the house are hidden under the reddish flower pot.</blockquote>

<p>When we convert the plaintext into the encoded message, we call this <span class='term'>encrypting</span> the plaintext. The plaintext is encrypted into the <span class='term'>ciphertext</span>. The ciphertext looks like random letters (also called <span class='term'>garbage data</span>), and we cannot understand what the original plaintext was by just looking at the ciphertext. Here is an example of some ciphertext:</p>

<blockquote style="sourceblurb">Ckkz fkx kj becqnejc kqp pdeo oaynap iaoowca!</blockquote>

<p>But if we know about the cipher used to encrypt the message, we can convert the ciphertext back to the plaintext. This is called <span class='term'>decrypting</span>. (Decryption is the opposite of encryption.)</p>

<p>Many ciphers also use keys. <span class='term'>Keys</span> are secret values that let you decrypt ciphertext that was encrypted using a specific cipher. Think of the cipher as being like a door lock. Although all the door locks of the same type are built the same, a particular lock will only unlock if you have the key made for that lock. You cannot use another key on that door lock, and you cannot use a different key to decrypt ciphertext that was encrypted with a different key.</p>

<p>When we encrypt a message using a cipher, we will choose the key that is used to encrypt and decrypt this message. The key for our Caesar Cipher will be a number from 1 to 26. Unless you know the key (that is, know the number), you will not be able to decrypt the encrypted message.</p>

<p>The <span class='term'>Caesar Cipher</span> was one of the earliest ciphers ever invented. In this cipher, you encrypt a message by taking each letter in the message (in cryptography, these letters are called <span class='term'>symbols</span> because they can be letters, numbers, or any other sign) and replacing it with a "shifted" letter. If you shift the letter A by one space, you get the letter B. If you shift the letter A by two spaces, you get the letter C. Here is a picture of some letters shifted over by 3 spaces:</p>

<p class='centeredImageP'><img src='images/11_caesar.png' class='centeredImage'></p>

<p>To get each shifted letter, draw out a row of boxes with each letter of the alphabet. Then draw a second row of boxes under it, but start a certain number of spaces over. When you get to the leftover letters at the end, wrap around back to the start of the boxes. Here is an example with the letters shifted by three spaces:</p>

<p class='centeredImageP'><img src='images/11_shifted.png' class='centeredImage'></p>

<p>The number of spaces we shift is the key in the Caesar Cipher. The example above shows the key 3.</p>

<p>Using a key of 3, if we encrypt the plaintext "Howdy", then the "H" becomes "E". "o" becomes "l". "w" becomes "t". "d" becomes "a". "y" becomes "v". The ciphertext of "Hello" with key 3 becomes "Eltav".</p>

<p>We will keep any non-letter characters the same. In order to decrypt "Eltav" with the key 3, we just go from the bottom boxes back to the top. "E" becomes "H", "l" becomes "o", "t" becomes "w", "a" becomes "d", and "v" becomes "y" to form "Howdy".</p>

<h2>ASCII, and Using Numbers for Letters</h2>

<p>How do we implement this shifting of the letters in our program? We can do this by representing each letter as a number (called an <span class='term'>ordinal</span>), and then adding or subtracting from this number to form a new number (and a new letter). ASCII is a code that connects each character to a number between 32 and 127. The numbers less than 32 refer to "unprintable" characters, so we will not be using them.</p>

<p>For example, the letter "A" is represented by the number 65. The letter "m" is represented by the number 109. Here is a table of all the ASCII characters from 32 to 127:</p>

<table border="0" align="center">
<tr><td style="padding: 20px; vertical-align: top;">
<table class='simpletable'>
<tr><td class='simpletd'>32</td><td class='simpletd'>(space)</td></tr>
<tr><td class='simpletd'>33</td><td class='simpletd'>!</td></tr>
<tr><td class='simpletd'>34</td><td class='simpletd'>"</td></tr>
<tr><td class='simpletd'>35</td><td class='simpletd'>#</td></tr>
<tr><td class='simpletd'>36</td><td class='simpletd'>$</td></tr>
<tr><td class='simpletd'>37</td><td class='simpletd'>%</td></tr>
<tr><td class='simpletd'>38</td><td class='simpletd'>&amp;</td></tr>
<tr><td class='simpletd'>39</td><td class='simpletd'>'</td></tr>
<tr><td class='simpletd'>40</td><td class='simpletd'>(</td></tr>
<tr><td class='simpletd'>41</td><td class='simpletd'>)</td></tr>
<tr><td class='simpletd'>42</td><td class='simpletd'>*</td></tr>
<tr><td class='simpletd'>43</td><td class='simpletd'>+</td></tr>
<tr><td class='simpletd'>44</td><td class='simpletd'>,</td></tr>
<tr><td class='simpletd'>45</td><td class='simpletd'>-</td></tr>
<tr><td class='simpletd'>46</td><td class='simpletd'>.</td></tr>
<tr><td class='simpletd'>47</td><td class='simpletd'>/</td></tr>
</table>

</td><td style="padding: 20px; vertical-align: top;">

<table class='simpletable'>
<tr><td class='simpletd'>48</td><td class='simpletd'>0</td></tr>
<tr><td class='simpletd'>49</td><td class='simpletd'>1</td></tr>
<tr><td class='simpletd'>50</td><td class='simpletd'>2</td></tr>
<tr><td class='simpletd'>51</td><td class='simpletd'>3</td></tr>
<tr><td class='simpletd'>52</td><td class='simpletd'>4</td></tr>
<tr><td class='simpletd'>53</td><td class='simpletd'>5</td></tr>
<tr><td class='simpletd'>54</td><td class='simpletd'>6</td></tr>
<tr><td class='simpletd'>55</td><td class='simpletd'>7</td></tr>
<tr><td class='simpletd'>56</td><td class='simpletd'>8</td></tr>
<tr><td class='simpletd'>57</td><td class='simpletd'>9</td></tr>
<tr><td class='simpletd'>58</td><td class='simpletd'>:</td></tr>
<tr><td class='simpletd'>59</td><td class='simpletd'>;</td></tr>
<tr><td class='simpletd'>60</td><td class='simpletd'>&lt;</td></tr>
<tr><td class='simpletd'>61</td><td class='simpletd'>=</td></tr>
<tr><td class='simpletd'>62</td><td class='simpletd'>&gt;</td></tr>
<tr><td class='simpletd'>63</td><td class='simpletd'>?</td></tr>
</table>

</td><td style="padding: 20px; vertical-align: top;">

<table class='simpletable'>
<tr><td class='simpletd'>64</td><td class='simpletd'>@</td></tr>
<tr><td class='simpletd'>65</td><td class='simpletd'>A</td></tr>
<tr><td class='simpletd'>66</td><td class='simpletd'>B</td></tr>
<tr><td class='simpletd'>67</td><td class='simpletd'>C</td></tr>
<tr><td class='simpletd'>68</td><td class='simpletd'>D</td></tr>
<tr><td class='simpletd'>69</td><td class='simpletd'>E</td></tr>
<tr><td class='simpletd'>70</td><td class='simpletd'>F</td></tr>
<tr><td class='simpletd'>71</td><td class='simpletd'>G</td></tr>
<tr><td class='simpletd'>72</td><td class='simpletd'>H</td></tr>
<tr><td class='simpletd'>73</td><td class='simpletd'>I</td></tr>
<tr><td class='simpletd'>74</td><td class='simpletd'>J</td></tr>
<tr><td class='simpletd'>75</td><td class='simpletd'>K</td></tr>
<tr><td class='simpletd'>76</td><td class='simpletd'>L</td></tr>
<tr><td class='simpletd'>77</td><td class='simpletd'>M</td></tr>
<tr><td class='simpletd'>78</td><td class='simpletd'>N</td></tr>
<tr><td class='simpletd'>79</td><td class='simpletd'>O</td></tr>
</table>

</td><td style="padding: 20px; vertical-align: top;">

<table class='simpletable'>
<tr><td class='simpletd'>80</td><td class='simpletd'>P</td></tr>
<tr><td class='simpletd'>81</td><td class='simpletd'>Q</td></tr>
<tr><td class='simpletd'>82</td><td class='simpletd'>R</td></tr>
<tr><td class='simpletd'>83</td><td class='simpletd'>S</td></tr>
<tr><td class='simpletd'>84</td><td class='simpletd'>T</td></tr>
<tr><td class='simpletd'>85</td><td class='simpletd'>U</td></tr>
<tr><td class='simpletd'>86</td><td class='simpletd'>V</td></tr>
<tr><td class='simpletd'>87</td><td class='simpletd'>W</td></tr>
<tr><td class='simpletd'>88</td><td class='simpletd'>X</td></tr>
<tr><td class='simpletd'>89</td><td class='simpletd'>Y</td></tr>
<tr><td class='simpletd'>90</td><td class='simpletd'>Z</td></tr>
<tr><td class='simpletd'>91</td><td class='simpletd'>[</td></tr>
<tr><td class='simpletd'>92</td><td class='simpletd'>\</td></tr>
<tr><td class='simpletd'>93</td><td class='simpletd'>]</td></tr>
<tr><td class='simpletd'>94</td><td class='simpletd'>^</td></tr>
<tr><td class='simpletd'>95</td><td class='simpletd'>_</td></tr>
</table>

</td><td style="padding: 20px; vertical-align: top;">

<table class='simpletable'>
<tr><td class='simpletd'>96</td><td class='simpletd'>`</td></tr>
<tr><td class='simpletd'>97</td><td class='simpletd'>a</td></tr>
<tr><td class='simpletd'>98</td><td class='simpletd'>b</td></tr>
<tr><td class='simpletd'>99</td><td class='simpletd'>c</td></tr>
<tr><td class='simpletd'>100</td><td class='simpletd'>d</td></tr>
<tr><td class='simpletd'>101</td><td class='simpletd'>e</td></tr>
<tr><td class='simpletd'>102</td><td class='simpletd'>f</td></tr>
<tr><td class='simpletd'>103</td><td class='simpletd'>g</td></tr>
<tr><td class='simpletd'>104</td><td class='simpletd'>h</td></tr>
<tr><td class='simpletd'>105</td><td class='simpletd'>i</td></tr>
<tr><td class='simpletd'>106</td><td class='simpletd'>j</td></tr>
<tr><td class='simpletd'>107</td><td class='simpletd'>k</td></tr>
<tr><td class='simpletd'>108</td><td class='simpletd'>l</td></tr>
<tr><td class='simpletd'>109</td><td class='simpletd'>m</td></tr>
<tr><td class='simpletd'>110</td><td class='simpletd'>n</td></tr>
<tr><td class='simpletd'>111</td><td class='simpletd'>o</td></tr>
</table>

</td><td style="padding: 20px; vertical-align: top;">

<table class='simpletable'>
<tr><td class='simpletd'>112</td><td class='simpletd'>p</td></tr>
<tr><td class='simpletd'>113</td><td class='simpletd'>q</td></tr>
<tr><td class='simpletd'>114</td><td class='simpletd'>r</td></tr>
<tr><td class='simpletd'>115</td><td class='simpletd'>s</td></tr>
<tr><td class='simpletd'>116</td><td class='simpletd'>t</td></tr>
<tr><td class='simpletd'>117</td><td class='simpletd'>u</td></tr>
<tr><td class='simpletd'>118</td><td class='simpletd'>v</td></tr>
<tr><td class='simpletd'>119</td><td class='simpletd'>w</td></tr>
<tr><td class='simpletd'>120</td><td class='simpletd'>x</td></tr>
<tr><td class='simpletd'>121</td><td class='simpletd'>y</td></tr>
<tr><td class='simpletd'>122</td><td class='simpletd'>z</td></tr>
<tr><td class='simpletd'>123</td><td class='simpletd'>{</td></tr>
<tr><td class='simpletd'>124</td><td class='simpletd'>|</td></tr>
<tr><td class='simpletd'>125</td><td class='simpletd'>}</td></tr>
<tr><td class='simpletd'>126</td><td class='simpletd'>~</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
</table>

</td></tr></table>

<p>The capital letters "A" through "Z" have the numbers 65 through 90. The lowercase letters "a" through "z" have the numbers 97 through 122. The numeric digits "0" through "9" have the numbers 48 through 57.</p>

<p>So if we wanted to shift "A" by three spaces, we first convert it to the number 65. Then we add 3 to 65, to get 68. The number 68 is connected to the letter "D".</p>

<h2>The <span class='m'>chr()</span> and <span class='m'>ord()</span> Functions</h2>

<p>The <span class='m'>chr()</span> function (short for "character") takes a single-character string for the parameter, and returns the integer ASCII number for that string. The <span class='m'>ord()</span> function (short for "ordinal") takes an integer for the parameter, and returns the ASCII letter for that number. Try typing the following into the interactive shell:</p>

<blockquote class='sourceblurb'>
chr(65)<br/>
ord('A')<br/>
chr(65+8)<br/>
chr(52)<br/>
chr(ord('F'))<br/>
ord(chr(68))<br/>
</blockquote>

<p class='centeredImageP'><img src='images/11_ordchr.png' class='centeredImage'></p>

<p>On the third line, <span class='m'>chr(65+8)</span> evaluates to <span class='m'>chr(73)</span>. If you look at the ASCII table, you can see that 73 is the ordinal for the capital letter "I". On the fifth line, <span class='m'>chr(ord('F'))</span> evaluates to <span class='m'>chr(70)</span> which evaluates to <span class='m'>'F'</span>. Feeding the result of <span class='m'>ord()</span> to <span class='m'>chr()</span> will give you back the original argument. The same goes for feeding the result of <span class='m'>chr()</span> to <span class='m'>ord()</span>, as shown by the sixth line.</p>

<p>Using <span class='m'>chr()</span> and <span class='m'>ord()</span> will come in handy for our Caesar Cipher program, and also whenever we need to do math operations on strings as if they were numbers.</p>

<h2>Sample Run</h2>
<p>Here is a sample run of the Caesar Cipher program, encrypting a message:</p>

<blockquote class="samplerun">
Do you wish to encrypt or decrypt a message?<br/>
<span class="sampleruninput">encrypt</span><br/>
Enter your message:<br/>
<span class="sampleruninput">The sky above the port was the color of television, tuned to a dead channel.</span><br/>
Enter the key number (1-26)<br/>
<span class="sampleruninput">13</span><br/>
Your translated text is:<br/>
Gur fxl nobir gur cbeg jnf gur pbybe bs gryrivfvba, gharq gb n qrnq punaary.<br/>
</blockquote>

<p>Now we will run the program and decrypt the text that we just encrypted.</p>

<blockquote class="samplerun">
Do you wish to encrypt or decrypt a message?<br/>
<span class="sampleruninput">decrypt</span><br/>
Enter your message:<br/>
<span class="sampleruninput">Gur fxl nobir gur cbeg jnf gur pbybe bs gryrivfvba, gharq gb n qrnq punaary.</span><br/>
Enter the key number (1-26)<br/>
<span class="sampleruninput">13</span><br/>
Your translated text is:<br/>
The sky above the port was the color of television, tuned to a dead channel.<br/>
</blockquote>

<p>On this run we will try to decrypt the text that was encrypted, but we will use the wrong key. Remember that if you do not know the correct key, the decrypted text will just be garbage data.</p>

<blockquote class="samplerun">
Do you wish to encrypt or decrypt a message?<br/>
<span class="sampleruninput">decrypt</span><br/>
Enter your message:<br/>
<span class="sampleruninput">Gur fxl nobir gur cbeg jnf gur pbybe bs gryrivfvba, gharq gb n qrnq punaary.</span><br/>
Enter the key number (1-26)<br/>
<span class="sampleruninput">15</span><br/>
Your translated text is:<br/>
Rfc qiw yzmtc rfc nmpr uyq rfc amjmp md rcjctgqgml, rslcb rm y bcyb afyllcj.<br/>
</blockquote>


<h2>Source Code</h2>

<blockquote class="sourcecode"><span class='sourcecodeHeader'>caesar.py</span><br/>
<ol start=1>
<li># Caesar Cipher - Simple Substitution Cipher</li>
<li></li>
<li>MAX_KEY_SIZE = 26</li>
<li></li>
<li>def getMode():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;while True:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Do you wish to encrypt or decrypt a message?'</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = raw_input().lower()</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode in 'encrypt e decrypt d'.split():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mode</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter either "encrypt" or "e" or "decrypt" or "d".'</li>
<li></li>
<li>def getMessage():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter your message:'</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;return raw_input()</li>
<li></li>
<li>def getKey():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;key = 0</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;while True:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter the key number (1-%s)' % (MAX_KEY_SIZE)</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = int(raw_input())</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (key >= 1 and key &lt;= MAX_KEY_SIZE):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return key </li>
<li></li>
<li>def getTranslatedMessage(mode, message, key):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;if mode[0] == 'd':</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = -key</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;translated = ''</li>
<li></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isalpha():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = ord(symbol)</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += key</li>
<li></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isupper():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num > ord('Z'):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num -= 26</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif num < ord('A'):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += 26</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif symbol.islower():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num > ord('z'):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num -= 26</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif num < ord('a'):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += 26</li><li></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += chr(num)</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += symbol</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;return translated</li>
<li></li>
<li>mode = getMode()</li>
<li>message = getMessage()</li>
<li>key = getKey()</li>
<li></li>
<li>print 'Your translated text is:'</li>
<li>print getTranslatedMessage(mode, message, key)</li>
<li></li>
</ol>
</blockquote>

<!-- TODO: When talking about ascii and data-as-numbers, be sure to drop a hint to unicode, and point to these two articles on the web:
http://en.wikipedia.org/wiki/Unicode
http://www.joelonsoftware.com/articles/Unicode.html
-->

<h2>Code Explanation</h2>

<blockquote class="sourcecode">
<ol start=1>
<li># Caesar Cipher - Simple Substitution Cipher</li>
<li></li>
<li>MAX_KEY_SIZE = 26</li>
</ol>
</blockquote>

<p>The first line is a comment. The Caesar Cipher is one cipher of a type of ciphers called simple substitution ciphers. <span class='term'>Simple substitution ciphers</span> are ciphers that replace one symbol in the plaintext with one (and only one) symbol in the ciphertext. So if a "G" was substituted with "Z" in the cipher, every single "G" in the plaintext would be replaced with (and only with) a "Z".</p>

<p><span class='m'>MAX_KEY_SIZE</span> is a variable that stores the integer <span class='m'>26</span> in it. <span class='m'>MAX_KEY_SIZE</span> reminds us that in this program, the key used in our cipher should be between 1 and 26.</p>

<br/>

<blockquote class="sourcecode">
<ol start=5>
<li>def getMode():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;while True:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Do you wish to encrypt or decrypt a message?'</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = raw_input().lower()</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode in 'encrypt e decrypt d'.split():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mode[0]</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter either "encrypt" or "e" or "decrypt" or "d".'</li>
</ol>
</blockquote>

<p>The <span class='m'>getMode()</span> function will let the user type in if they want to encrypt or decrypt the message. The return value of <span class='m'>raw_input()</span> (which then has the <span class='m'>lower()</span> method called on it, which returns the lowercase version of the string) is stored in <span class='m'>mode</span>. The <span class='m'>if</span> statement's condition checks if the string stored in <span class='m'>mode</span> exists in the list returned by <span class='m'>'encrypt e decrypt d'.split()</span>. This list is <span class='m'>['encrypt', 'e', 'decrypt', 'd']</span>, but it is easier for the programmer to just type in <span class='m'>'encrypt e decrypt d'.split()</span> and not type in all those quotes and commas. But you can use whatever is easiest for you; they both evaluate to the same list value.</p>

<p>This function will return the first character in <span class='m'>mode</span> as long as <span class='m'>mode</span> is equal to <span class='m'>'encrypt'</span>, <span class='m'>'e'</span>, <span class='m'>'decrypt'</span>, or <span class='m'>'d'</span>. This means that <span class='m'>getMode()</span> will return the string <span class='m'>'e'</span> or the string <span class='m'>'d'</span>.</p>

<br/>

<blockquote class="sourcecode">
<ol start=14>
<li>def getMessage():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter your message:'</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;return raw_input()</li>
</ol>
</blockquote>

<p>The <span class='m'>getMessage()</span> function simply gets the message to encrypt or decrypt from the user and uses this string as its return value.</p>

<br/>

<blockquote class="sourcecode">
<ol start=18>
<li>def getKey():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;key = 0</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;while True:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter the key number (1-%s)' % (MAX_KEY_SIZE)</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = int(raw_input())</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (key >= 1 and key &lt;= MAX_KEY_SIZE):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return key </li>
</ol>
</blockquote>

<p>The <span class='m'>getKey()</span> function lets the player type in key they will use to encrypt or decrypt the message. The <span class='m'>while</span> loop ensures that the function only returns a valid key. A valid key here is one that is between the integer values <span class='m'>1</span> and <span class='m'>26</span> (remember that <span class='m'>MAX_KEY_SIZE</span> will only have the value <span class='m'>26</span> because it is constant). It then returns this key. Remember that on line 363 that <span class='m'>key</span> was set to the integer version of what the user typed in, and so <span class='m'>getKey()</span> returns an integer.</p>

<!-- NOTE: With this code, the user could type in letters for the key and cause the program to crash. -->

<br/>

<blockquote class="sourcecode">
<ol start=26>
<li>def getTranslatedMessage(mode, message, key):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;if mode[0] == 'd':</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = -key</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;translated = ''</li>
<li></li>
</ol>
</blockquote>

<p><span class='m'>getTranslatedMessage()</span> is the function that does the encrypting and decrypting in our program. It has three parameters. <span class='m'>mode</span> sets the function to encryption mode or decryption mode. <span class='m'>message</span> is the plaintext/ciphertext to be encrypted/decrypted. <span class='m'>key</span> is the key that is used in this cipher.</p>

<p>The first line in the <span class='m'>getTranslatedMessage()</span> function determines if we are in encryption mode or decryption mode. If the first letter in the <span class='m'>MAX_KEY_SIZE</span> variable is the string <span class='m'>MAX_KEY_SIZE</span>, then we are in decryption mode. The only difference between the two modes is that in decryption mode, the <span class='m'>key</span> is set to the negative version of itself. If <span class='m'>key</span> was the integer <span class='m'>22</span>, then in decryption mode we set it to <span class='m'>-22</span>. The reason for this will be explained later.</p>

<p><span class='m'>translated</span> is the string that will hold the ciphertext (if we are encrypting) or the plaintext (if we are decrypting). We will only be concatenating strings to this variable, so we first set <span class='m'>translated</span> to the blank string. (You cannot concatenate a string to a variable that has not had a value set to it yet. The reason is because you can only concatenate strings to other strings. If the variable has no value, it is not of the string data type.)</p>

<br/>

<blockquote class="sourcecode">
<ol start=31>
<li>&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isalpha():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = ord(symbol)</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += key</li>
</ol>
</blockquote>

<p>We will run a <span class='m'>for</span> loop over each letter (remember that in cryptography, they are called symbols) in the <span class='m'>message</span> string. Strings are treated just like lists of single-character strings. If <span class='m'>message</span> had the string <span class='m'>'Hello'</span>, then <span class='m'>for symbol in 'Hello'</span> would be the same as <span class='m'>for symbol in ['H', 'e', 'l', 'l', 'o']</span>. On each iteration through this loop, <span class='m'>symbol</span> will have the value of a letter in <span class='m'>message</span>.</p>

<h2>The <span class='m'>isalpha()</span> String Method</h2>

<p>The <span class='m'>isalpha()</span> string method will return <span class='m'>True</span> if the string is an uppercase or lowercase letter from A to Z. If the string contains any non-letter characters, then <span class='m'>MAX_KEY_SIZE</span> will return <span class='m'>MAX_KEY_SIZE</span>. Try typing the following into the interactive shell:</p>

<blockquote class='sourceblurb'>
'Hello'.isalpha()<br/>
'Forty two'.isalpha()<br/>
'Fortytwo'.isalpha()<br/>
'42'.isalpha()<br/>
''.isalpha()<br/>
</blockquote>

<p class='centeredImageP'><img src='images/11_isalpha.png' class='centeredImage'></p>

<p>As you can see, <span class='m'>'Forty two'.isalpha()</span> will return <span class='m'>False</span> because <span class='m'>'Forty two'</span> has a space in it, which is a non-letter character. <span class='m'>'Fortytwo'.isalpha()</span> returns <span class='m'>True</span> because it does not have this space.</p>

<p><span class='m'>'42'.isalpha()</span> returns <span class='m'>False</span> because both <span class='m'>'4'</span> and <span class='m'>'2'</span> are non-letter characters. And <span class='m'>''.isalpha()</span> is <span class='m'>False</span> because <span class='m'>isalpha()</span> only returns <span class='m'>True</span> if the string has only letter characters and is not blank.</p>

<p>The reason we have the <span class='m'>if</span> statement on line 32 is because we will only encrypt/decrypt letters in the message. Numbers, signs, punctuation marks, and everything else will stay in their untranslated form.</p>

<p>The <span class='m'>num</span> variable will hold the integer ordinal value of the letter stored in <span class='m'>symbol</span>. Line 34 then "shifts" the value in <span class='m'>num</span> by the value in <span class='m'>key</span>.</p>
<!--
<h2>Code Explanation continued...</h2>

<blockquote class="sourcecode">
<ol start=35>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isupper():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num -= ord('A')</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif symbol.islower():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num -= ord('a')</li>
</ol>
</blockquote>
-->


<h2>The <span class='m'>isupper()</span> and <span class='m'>islower()</span> String Methods</h2>

<p>The <span class='m'>isupper()</span> and <span class='m'>islower()</span> string methods (which are on line 36 and 41) work in a way that is very similar to the <span class='m'>isdigit()</span> and <span class='m'>isalpha()</span> methods. <span class='m'>isupper()</span> will return <span class='m'>True</span> if the string it is called on contains at least one uppercase letter and no lowercase letters. <span class='m'>islower()</span> returns <span class='m'>True</span> if the string it is called on contains at least one lowercase letter and no uppercase letters. Otherwise these methods return <span class='m'>False</span>. The existence of non-letter characters like numbers and spaces does not affect the outcome. Although strings that do not have any letters, including blank strings, will also return <span class='m'>False</span>. Try typing the following into the interactive shell:</p>

<blockquote class='sourceblurb'>
'HELLO'.isupper()<br/>
'hello'.isupper()<br/>
'hello'.islower()<br/>
'Hello'.islower()<br/>
'LOOK OUT BEHIND YOU!'.isupper()<br/>
'42'.isupper()<br/>
'42'.islower()<br/>
''.isupper()<br/>
''.islower()<br/>
</blockquote>

<p class='centeredImageP'><img src='images/11_isupperislower.png' class='centeredImage'></p>

<h2>Code Explanation continued...</h2>

<blockquote class="sourcecode">
<ol start=36>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isupper():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num > ord('Z'):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num -= 26</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif num < ord('A'):</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += 26</li>
</ol>
</blockquote>

<!--
<p>We want to adjust the number in num to be between 0 and 25. But <span class='m'>num</span> is between 65 and 90 (for uppercase letters) or 97 and 122 (for lowercase letters). Here we subtract either 65 (<span class='m'>ord('A')</span>) or 97 (<span class='m'>ord('a')</span>) from <span class='m'>MAX_KEY_SIZE</span> using the shortcut subtraction operator. Remember that <span class='m'>num -= ord('A')</span> is the same thing as <span class='m'>num = num - ord('A')</span>, it's just shorter and easier for the programmer to type <span class='m'>-=</span>.</p>
-->

<p>This code checks if the symbol is an uppercase letter. If so, there are two special cases we need to worry about. What if <span class='m'>symbol</span> was <span class='m'>'Z'</span> and <span class='m'>key</span> was <span class='m'>4</span>? If that were the case, the value of <span class='m'>num</span> here would be the character <span class='m'>'^'</span>. But this isn't a letter at all. We wanted the ciphertext to "wrap around" to the beginning of the alphabet. The way we can do this is to check if <span class='m'>key</span> has a value larger than the largest possible letter's ASCII value (which is a capital "Z"). If so, then we want to subtract 26 (because there are 26 letters in total) from <span class='m'>num</span>. After doing this, the value of <span class='m'>num</span> is <span class='m'>68</span>, which is the ASCII value for <span class='m'>'D"</span>.</p>

<p>If we were decrypting, then <span class='m'>key</span> would be negative. Then we would have the special case where the new value of <span class='m'>num</span> might be less than the smallest possible value (which is <span class='m'>ord('A')</span>, that is, <span class='m'>65</span>). If this is the case, we want to add 26 to <span class='m'>26</span> to have it "wrap around".</p>

<br/>

<!--
<blockquote class="sourcecode">
<ol start=40>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += key</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = num % 26</li>
</ol>
</blockquote>

<p>Now we will add to <span class='m'>num</span> the value of <span class='m'>num</span>. Remember that in decryption mode, <span class='m'>key</span> is a negative number. Adding a negative number is the same thing as subtracting the positive form of that number. So in encryption mode, we are adding the value of <span class='m'>key</span>. In decryption mode, we are subtracting the (absolute) value of <span class='m'>key</span>.</p>

<p>Adding a positive value is the same as shifting the letters over one way, and adding a negative value is the same as shifting the letters the other way. This is how our encryption and decryption scheme works. If we use the same key to both encrypt and decrypt the message, than the letters are shifted by the same amount. That means the decrypted message will become the original message before it had been encrypted.</p>

<h2>The % Modulus Operator</h2>

<p>The <span class='m'>num</span> sign is a new mathematical operator, like addition operator <span class='m'>+</span>, subtraction operator <span class='m'>-</span>, multiplication operator <span class='m'>*</span>, and division operator <span class='m'>/</span>. It is called the modulus operator. The <span class='term'>modulus operator</span> works the way the division operator does, except that it returns the "remainder" of a division operation. If you divide 10 ÷ 3, the answer would be 3 with a remainder of 1. Similarly, if mod 10 % 3, the answer is 1.</p>

<p>Here are some division problems, and some similar modulus problems next to them:</p>

<table class='simpletable' align="center">
<tr><td class='simpletd' width="180">10 ÷ 3 = 3, remainder 1</td><td class='simpletd' width="180"><span class='m'>10 % 3 = 1</span></td></tr>
<tr><td class='simpletd' width="180">12 ÷ 6 = 2, remainder 0</td><td class='simpletd' width="180"><span class='m'>12 % 6 = 0</span></td></tr>
<tr><td class='simpletd' width="180">12 ÷ 5 = 2, remainder 2</td><td class='simpletd' width="180"><span class='m'>12 % 5 = 2</span></td></tr>
<tr><td class='simpletd' width="180">5 ÷ 8 = 0, remainder 5</td><td class='simpletd' width="180"><span class='m'>5 % 8 = 5</span></td></tr>
<tr><td class='simpletd' width="180">5 ÷ 9 = 0, remainder 5</td><td class='simpletd' width="180"><span class='m'>5 % 9 = 5</span></td></tr>
<tr><td class='simpletd' width="180">15 ÷ 8 = 1, remainder 7</td><td class='simpletd' width="180"><span class='m'>15 % 8 = 7</span></td></tr>
</table>

<p>As you can see, the modulus operation always evaluates to a number between 0 and the first number minus one.</p>

<p>In the Caesar Cipher, the modulus operator will help us with our wrap-around problem. This will be explained, but first let's look at the next few lines.</p>

<br/>

<blockquote class="sourcecode">
<ol start=43>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isupper():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += ord('A')</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif symbol.islower():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num += ord('a')</li>
</ol>
</blockquote>

<p>Lines 43 to 46 seem to do the exact opposite of lines 35 to 38. Instead of subtracting the value of <span class='m'>ord('A')</span> or <span class='m'>ord('a')</span>, they add the value <span class='m'>ord('A')</span> or <span class='m'>ord('a')</span>. Why do we subtract this value only to add it later?</p>

<p>The answer has to do with the modulus operation on line 41, and our wrap around problem. Let's see what happens when <span class='m'>symbol</span> has the value <span class='m'>'B'</span> and <span class='m'>key</span> has the value <span class='m'>3</span>:</p>

<blockquote class='sourceblurb'>
<table border='0'>
<tr><td>num = ord(symbol)</td><td># num is set to 66</td></tr>
<tr><td>num -= ord('A')</td><td># num is set to 66 - 65, that is, 1</td></tr>
<tr><td>num += key</td><td># num is set to 1 + 3, that is, 4</td></tr>
<tr><td>num = num % 26</td><td># num is set to 4 % 26, that is, 4</td></tr>
<tr><td>num += ord('A')</td><td># num is set to 4 + 65, that is, 69.</td></tr>
<tr><td></td><td># 69 is the ASCII ordinal value for "E"</td></tr>
</table>
</blockquote>

<p>This is as expected. The encrypted form of the letter "B" with a key of 3 is "E". You may wonder why we subtracted and added the value of <span class='m'>ord('A')</span>, or why the modulus operation was done. This is because sometimes adding the value of <span class='m'>key</span> could set <span class='m'>num</span> to an ASCII value of something that is not a letter. Let's see what happens if we remove those lines of code when <span class='m'>symbol</span> is <span class='m'>'B'</span> and <span class='m'>key</span> is <span class='m'>3</span>:</p>

<blockquote class='sourceblurb'>
<table border='0'>
<tr><td>num = ord(symbol)</td><td># num is set to 90</td></tr>
<tr><td>num += key</td><td># num is set to 90 + 3, that is, 93</td></tr>
<tr><td></td><td># 93 is the ASCII ordinal value for "]"</td></tr>
</table>
</blockquote>

<p>The character <span class='m'>']'</span> is not a letter. We want the encrypted text to only have letters in its output. "Z" should wrap around to "C". But if we add those lines of code back in, the code works:</p>

<blockquote class='sourceblurb'>
<table border='0'>
<tr><td>num = ord(symbol)</td><td># num is set to 90</td></tr>
<tr><td>num -= ord('A')</td><td># num is set to 90 - 65, that is, 25</td></tr>
<tr><td>num += key</td><td># num is set to 25 + 3, that is, 28</td></tr>
<tr><td>num = num % 26</td><td># num is set to 28 % 26, that is, 2</td></tr>
<tr><td>num += ord('A')</td><td># num is set to 2 + 65, that is, 67.</td></tr>
<tr><td></td><td># 67 is the ASCII ordinal value for "C"</td></tr>
</table>
</blockquote>

<br/>
-->

<blockquote class="sourcecode">
<ol start=47>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += chr(num)</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += symbol</li>
</ol>
</blockquote>

<p>The <span class='m'>translated</span> string will be appended with the encrypted/decrypted character. If the symbol was not an uppercase or lowercase letter, then the else-block on line 48 would have executed instead. All the code in the else-block does is append the original symbol to the <span class='m'>translated</span> string. This means that spaces, numbers, punctuation marks, and other characters will not be encrypted (or decrypted).</p>

<br/>

<blockquote class="sourcecode">
<ol start=50>
<li>&nbsp;&nbsp;&nbsp;&nbsp;return translated</li>
</ol>
</blockquote>

<p>The last line in the <span class='m'>getTranslatedMessage()</span> function returns the <span class='m'>translated</span> string.</p>

<br/>

<blockquote class="sourcecode">
<ol start=52>
<li>mode = getMode()</li>
<li>message = getMessage()</li>
<li>key = getKey()</li>
<li></li>
<li>print 'Your translated text is:'</li>
<li>print getTranslatedMessage(mode, message, key)</li>
</ol>
</blockquote>

<p>This is the main part of our program. We call each of the three functions we have defined above in turn to get the mode, message, and key that the user wants to use. We then pass these three values as arguments to <span class='m'>getTranslatedMessage()</span>, whose return value (the translated string) is printed to the user.</p>

<!--
<h2>Cryptanalysis</h2>

<p>That's the entire Caesar Cipher. However, while this cipher may fool some people who don't understand cryptography, it won't keep a message secret from someone who knows cryptanalysis. While cryptography is the science of making codes, <span class='term'>cryptanalysis</span> is the study of breaking codes. Let's look at a sample run of this program that encrypts our secret message:</p>

<blockquote class="samplerun">
Do you wish to encrypt or decrypt a message?<br/>
<span class="sampleruninput">encrypt</span><br/>
Enter your message:<br/>
<span class="sampleruninput">The door key will be hidden under the mat until the fourth of July.</span><br/>
Enter the key number (1-26)<br/>
<span class="sampleruninput">8</span><br/>
Your translated text is:<br/>
Bpm lwwz smg eqtt jm pqllmv cvlmz bpm uib cvbqt bpm nwczbp wn Rctg.<br/>
</blockquote>

<p>The entire point of secret codes is that so if someone else gets their hands on the encrypted message, they cannot figure out the original unencrypted message from it. So we pretend we are the attacker and all we have is the encrypted text:</p>

<blockquote>
Bpm lwwz smg eqtt jm pqllmv cvlmz bpm uib cvbqt bpm nwczbp wn Rctg.
</blockquote>

<p>The first thing a cryptanalyst would see is that there are several spaces in this message. Also, the first symbol is a capitalized letter and the last symbol is a period. So they would guess that this is a substitution cipher that replaces each letter with one (and only one) letter, and the case is preserved. This would make them think that a simple substitution cipher was used to encrypt the message.</p>

<p>They could confirm this by a frequency analysis. A <span class='term'>frequency analysis</span> is a look at how many of each letter there is in the message (and what percentage of the total this is). For example, in the encrypted string, here are the frequencies:</p>

<table border='0' align='center'><tr><td>
<table class='simpletable'>
<tr><td class='simpletd'>a</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
<tr><td class='simpletd'>b</td><td class='simpletd'>6</td><td class='simpletd'>11.321%</td></tr>
<tr><td class='simpletd'>c</td><td class='simpletd'>4</td><td class='simpletd'>7.547%</td></tr>
<tr><td class='simpletd'>d</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
<tr><td class='simpletd'>e</td><td class='simpletd'>1</td><td class='simpletd'>1.887%</td></tr>
<tr><td class='simpletd'>f</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>g</td><td class='simpletd'>2</td><td class='simpletd'>3.774%</td></tr>
<tr><td class='simpletd'>h</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
<tr><td class='simpletd'>i</td><td class='simpletd'>1</td><td class='simpletd'>1.887%</td></tr>
<tr><td class='simpletd'>j</td><td class='simpletd'>1</td><td class='simpletd'>1.887%</td></tr>
<tr><td class='simpletd'>k</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
<tr><td class='simpletd'>l</td><td class='simpletd'>4</td><td class='simpletd'>7.547%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>m</td><td class='simpletd'>7</td><td class='simpletd'>13.208%</td></tr>
<tr><td class='simpletd'>n</td><td class='simpletd'>2</td><td class='simpletd'>3.774%</td></tr>
<tr><td class='simpletd'>o</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
<tr><td class='simpletd'>p</td><td class='simpletd'>5</td><td class='simpletd'>9.434%</td></tr>
<tr><td class='simpletd'>q</td><td class='simpletd'>3</td><td class='simpletd'>5.66%</td></tr>
<tr><td class='simpletd'>r</td><td class='simpletd'>1</td><td class='simpletd'>1.887%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>s</td><td class='simpletd'>1</td><td class='simpletd'>1.887%</td></tr>
<tr><td class='simpletd'>t</td><td class='simpletd'>4</td><td class='simpletd'>7.547%</td></tr>
<tr><td class='simpletd'>u</td><td class='simpletd'>1</td><td class='simpletd'>1.887%</td></tr>
<tr><td class='simpletd'>v</td><td class='simpletd'>3</td><td class='simpletd'>5.66%</td></tr>
<tr><td class='simpletd'>w</td><td class='simpletd'>4</td><td class='simpletd'>7.547%</td></tr>
<tr><td class='simpletd'>x</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>y</td><td class='simpletd'>0</td><td class='simpletd'>0.0%</td></tr>
<tr><td class='simpletd'>z</td><td class='simpletd'>3</td><td class='simpletd'>5.66%</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
</table>

</td></tr></table>

<p>Then we can compare these frequencies with the frequenies of the English language. You could either get this information by grabbing several newspaper articles and books, and counting the letter frequencies, or you can look up these tables on the Internet. Here is one for your convenience:</p>

<table border='0' align='center'><tr><td>
<table class='simpletable'>
<tr><td class='simpletd'>a</td><td class='simpletd'>8.167%</td></tr>
<tr><td class='simpletd'>b</td><td class='simpletd'>1.492%</td></tr>
<tr><td class='simpletd'>c</td><td class='simpletd'>2.782%</td></tr>
<tr><td class='simpletd'>d</td><td class='simpletd'>4.253%</td></tr>
<tr><td class='simpletd'>e</td><td class='simpletd'>12.702%</td></tr>
<tr><td class='simpletd'>f</td><td class='simpletd'>2.228%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>g</td><td class='simpletd'>2.015%</td></tr>
<tr><td class='simpletd'>h</td><td class='simpletd'>6.094%</td></tr>
<tr><td class='simpletd'>i</td><td class='simpletd'>6.966%</td></tr>
<tr><td class='simpletd'>j</td><td class='simpletd'>0.153%</td></tr>
<tr><td class='simpletd'>k</td><td class='simpletd'>0.772%</td></tr>
<tr><td class='simpletd'>l</td><td class='simpletd'>4.025%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>m</td><td class='simpletd'>2.406%</td></tr>
<tr><td class='simpletd'>n</td><td class='simpletd'>6.749%</td></tr>
<tr><td class='simpletd'>o</td><td class='simpletd'>7.507%</td></tr>
<tr><td class='simpletd'>p</td><td class='simpletd'>1.929%</td></tr>
<tr><td class='simpletd'>q</td><td class='simpletd'>0.095%</td></tr>
<tr><td class='simpletd'>r</td><td class='simpletd'>5.987%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>s</td><td class='simpletd'>6.327%</td></tr>
<tr><td class='simpletd'>t</td><td class='simpletd'>9.056%</td></tr>
<tr><td class='simpletd'>u</td><td class='simpletd'>2.758%</td></tr>
<tr><td class='simpletd'>v</td><td class='simpletd'>0.978%</td></tr>
<tr><td class='simpletd'>w</td><td class='simpletd'>2.360%</td></tr>
<tr><td class='simpletd'>x</td><td class='simpletd'>0.150%</td></tr>
</table>

</td><td>&nbsp;&nbsp;</td><td>

<table class='simpletable'>
<tr><td class='simpletd'>y</td><td class='simpletd'>1.974%</td></tr>
<tr><td class='simpletd'>z</td><td class='simpletd'>0.074%</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
<tr><td class='simpletd'>&nbsp;</td><td class='simpletd'>&nbsp;</td></tr>
</table>

</td></tr></table>
-->

<h2>Brute Force</h2>
<p>That's the entire Caesar Cipher. However, while this cipher may fool some people who don't understand cryptography, it won't keep a message secret from someone who knows cryptanalysis. While cryptography is the science of making codes, <span class='term'>cryptanalysis</span> is the study of breaking codes.</p>

<blockquote class="samplerun">
Do you wish to encrypt or decrypt a message?<br/>
<span class="sampleruninput">encrypt</span><br/>
Enter your message:<br/>
<span class="sampleruninput">The door key will be hidden under the mat until the fourth of July.</span><br/>
Enter the key number (1-26)<br/>
<span class="sampleruninput">8</span><br/>
Your translated text is:<br/>
Bpm lwwz smg eqtt jm pqllmv cvlmz bpm uib cvbqt bpm nwczbp wn Rctg.<br/>
</blockquote>

<p>The whole point of cryptography is that so if someone else gets their hands on the encrypted message, they cannot figure out the original unencrypted message from it. So we pretend we are the attacker and all we have is the encrypted text:</p>

<blockquote>
Bpm lwwz smg eqtt jm pqllmv cvlmz bpm uib cvbqt bpm nwczbp wn Rctg.
</blockquote>

<p>One method of cryptanalysis is called brute force. <span class='term'>Brute force</span> is the technique of trying every single possible key. If the cryptanalyst knows the cipher that the message uses (or at least guesses it), they can just go through every possible key. Because there are only 26 possible keys, it would be easy for a cryptanalyst to write a program than prints the decrypted ciphertext of every possible key and see if any of the outputs make sense. Let's add a brute force feature to our program.</p>

<p>First, change lines 7, 9, and 12 (which are in the <span class='m'>cryptanalysis</span> to look like the following (the changes are in bold):</p>

<blockquote class="sourcecode">
<ol start=5>
<li>def getMode():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;while True:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Do you wish to encrypt or decrypt <b>or brute force</b> a message?'</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = raw_input().lower()</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode in 'encrypt e decrypt d <b>brute b</b>'.split():</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mode[0]</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print 'Enter either "encrypt" or "e" or "decrypt" or "d" <b>or "brute" or "b"</b>.'</li>
</ol>
</blockquote>

<p>This will let us select "brute force" as a mode for our program. Then modify and add the following changes to the main part of the program:</p>

<blockquote class="sourcecode">
<ol start=52>
<li>mode = getMode()</li>
<li>message = getMessage()</li>
<li><b>if mode[0] != 'b':</b></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;key = getKey()</li>
<li></li>
<li>print 'Your translated text is:'</li>
<li><b>if mode[0] != 'b':</b></li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;print getTranslatedMessage(mode, message, key)</li>
<li><b>else:</b></li>
<li><b>&nbsp;&nbsp;&nbsp;&nbsp;for key in range(1, MAX_KEY_SIZE + 1):</b></li>
<li><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print key, getTranslatedMessage('decrypt', message, key)</b></li>
</ol>
</blockquote>

<p>These changes make our program ask the user for a key if they are not in "brute force" mode. If they are not in "brute force" mode, then the original <span class='m'>getTranslatedMessage()</span> call is made and the translated string is printed.</p>

<p>However, otherwise we are in "brute force" mode, and we run a <span class='m'>getTranslatedMessage()</span> loop that iterates from <span class='m'>1</span> all the way up to <span class='m'>MAX_KEY_SIZE</span> (which is <span class='m'>26</span>). Remember that when the <span class='m'>range()</span> function returns a list of integers up to but not including the second parameter, which is why we have <span class='m'>+ 1</span>. This program will print out every possible translation of the message (including the key number used in the translation). Here is a sample run of this modified program:</p>

<blockquote class="samplerun" style="font-size: x-small;">
Do you wish to encrypt or decrypt or brute force a message?<br/>
<span class="sampleruninput">brute</span><br/>
Enter your message:<br/>
<span class="sampleruninput">Bpm lwwz smg eqtt jm pqllmv cvlmz bpm uib cvbqt bpm nwczbp wn Rctg.</span><br/>
Your translated text is:<br/>
1 Aol kvvy rlf dpss il opkklu bukly aol tha buaps aol mvbyao vm Qbsf.<br/>
2 Znk juux qke corr hk nojjkt atjkx znk sgz atzor znk luaxzn ul Pare.<br/>
3 Ymj ittw pjd bnqq gj mniijs zsijw ymj rfy zsynq ymj ktzwym tk Ozqd.<br/>
4 Xli hssv oic ampp fi lmhhir yrhiv xli qex yrxmp xli jsyvxl sj Nypc.<br/>
5 Wkh grru nhb zloo eh klgghq xqghu wkh pdw xqwlo wkh irxuwk ri Mxob.<br/>
6 Vjg fqqt mga yknn dg jkffgp wpfgt vjg ocv wpvkn vjg hqwtvj qh Lwna.<br/>
7 Uif epps lfz xjmm cf ijeefo voefs uif nbu voujm uif gpvsui pg Kvmz.<br/>
8 The door key will be hidden under the mat until the fourth of July.<br/>
9 Sgd cnnq jdx vhkk ad ghccdm tmcdq sgd lzs tmshk sgd entqsg ne Itkx.<br/>
10 Rfc bmmp icw ugjj zc fgbbcl slbcp rfc kyr slrgj rfc dmsprf md Hsjw.<br/>
11 Qeb allo hbv tfii yb efaabk rkabo qeb jxq rkqfi qeb clroqe lc Griv.<br/>
12 Pda zkkn gau sehh xa dezzaj qjzan pda iwp qjpeh pda bkqnpd kb Fqhu.<br/>
13 Ocz yjjm fzt rdgg wz cdyyzi piyzm ocz hvo piodg ocz ajpmoc ja Epgt.<br/>
14 Nby xiil eys qcff vy bcxxyh ohxyl nby gun ohncf nby ziolnb iz Dofs.<br/>
15 Max whhk dxr pbee ux abwwxg ngwxk max ftm ngmbe max yhnkma hy Cner.<br/>
16 Lzw vggj cwq oadd tw zavvwf mfvwj lzw esl mflad lzw xgmjlz gx Bmdq.<br/>
17 Kyv uffi bvp nzcc sv yzuuve leuvi kyv drk lekzc kyv wfliky fw Alcp.<br/>
18 Jxu teeh auo mybb ru xyttud kdtuh jxu cqj kdjyb jxu vekhjx ev Zkbo.<br/>
19 Iwt sddg ztn lxaa qt wxsstc jcstg iwt bpi jcixa iwt udjgiw du Yjan.<br/>
20 Hvs rccf ysm kwzz ps vwrrsb ibrsf hvs aoh ibhwz hvs tcifhv ct Xizm.<br/>
21 Gur qbbe xrl jvyy or uvqqra haqre gur zng hagvy gur sbhegu bs Whyl.<br/>
22 Ftq paad wqk iuxx nq tuppqz gzpqd ftq ymf gzfux ftq ragdft ar Vgxk.<br/>
23 Esp ozzc vpj htww mp stoopy fyopc esp xle fyetw esp qzfces zq Ufwj.<br/>
24 Dro nyyb uoi gsvv lo rsnnox exnob dro wkd exdsv dro pyebdr yp Tevi.<br/>
25 Cqn mxxa tnh fruu kn qrmmnw dwmna cqn vjc dwcru cqn oxdacq xo Sduh.<br/>
26 Bpm lwwz smg eqtt jm pqllmv cvlmz bpm uib cvbqt bpm nwczbp wn Rctg.<br/>
</blockquote>

<p>After looking over each row, you can see that the 8th message is not garbage, but plain English! The cryptanalyst can deduce that the original key for this encrypted text must have been <span class='m'>8</span>. This brute force would have been difficult to do back in the days of Caesars and the Roman Empire, but today we have computers that can quickly go through millions or even billions or keys. You can even write a program that can recognize when it has found a message in English, so you don't have read through all the garbage text. (In fact, we will do this in the next Invent Your Own Computer Games with Python book!)</p>

<blockquote class='inthischapter'><h3>Things Covered In This Chapter:</h3>
<ul>
<li>Cryptography and ciphers</li>
<li>Encrypting and decrypting</li>
<li>Ciphertext, plaintext, keys, and symbols</li>
<li>The Caesar Cipher</li>
<li>ASCII ordinal values</li>
<li>The <span class='m'>chr()</span> and <span class='m'>ord()</span> functions</li>
<li>The <span class='m'>isalpha()</span> string method</li>
<li>The <span class='m'>isupper()</span> and <span class='m'>islower()</span> string methods</li>
<li>Cryptanalysis</li>
<li>The brute force technique</li>
</ul>
</blockquote>

</body>
</html>